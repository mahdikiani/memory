"""Base model for SurrealDB entities."""

import logging
from collections.abc import Callable
from datetime import datetime, timezone
from typing import Self

from pydantic import BaseModel, ConfigDict, Field, GetJsonSchemaHandler
from pydantic.json_schema import JsonSchemaValue
from pydantic_core import core_schema
from surrealdb import RecordID

from .manager import AsyncSurrealConnection, DatabaseManager
from .query_builder import query
from .utils import camel_to_kebab

logger = logging.getLogger(__name__)


class RecordId(str):
    """SurrealDB record id."""

    @classmethod
    def __get_pydantic_core_schema__(
        cls, source: object, handler: Callable[[object], core_schema.CoreSchema]
    ) -> core_schema.CoreSchema:
        """Get Pydantic core schema for RecordId."""
        # Use a plain validator so we can accept multiple Python input types
        # (e.g. RecordID, dict, objects with tb/id attrs) and normalize them
        # to our RecordId string representation.
        return core_schema.no_info_plain_validator_function(cls.validate)

    @classmethod
    def __get_pydantic_json_schema__(
        cls, core_schema: core_schema.CoreSchema, handler: GetJsonSchemaHandler
    ) -> JsonSchemaValue:
        """Get JSON schema for RecordId (serialized as string)."""
        return {
            "type": "string",
            "format": "record-id",
            "description": "SurrealDB record ID",
        }

    @classmethod
    def validate(cls, value: object) -> Self:
        """Validate SurrealDB record id."""
        # If value is itself a RecordId
        if isinstance(value, cls):
            return value

        # If value is a string
        if isinstance(value, str):
            return cls._from_str(value)

        # If value is a RecordID (library class/your own)
        if isinstance(value, RecordID):
            return cls._from_str(str(value))

        # If value is a dict similar to {tb, id}
        if isinstance(value, dict) and "tb" in value and "id" in value:
            return cls._from_str(f"{value['tb']}:{value['id']}")

        # If value is an object with table/tb and id/identifier attributes
        tb = (
            getattr(value, "tb", None)
            or getattr(value, "table", None)
            or getattr(value, "table_name", None)
        )
        rid = getattr(value, "id", None) or getattr(value, "identifier", None)
        if tb is not None and rid is not None:
            return cls._from_str(f"{tb}:{rid}")

        raise TypeError(f"Unsupported RecordId value: {type(value)!r} {value!r}")

    @classmethod
    def _from_str(cls, s: str) -> Self:
        """Create a RecordId from a string."""
        if ":" not in s:
            raise ValueError("Invalid SurrealDB record id (expected 'table:id')")
        table, _ = s.split(":", 1)
        if not table:
            raise ValueError("Invalid SurrealDB record id (empty table)")
        return cls(s)

    def to_record_id(self) -> RecordID:
        """
        Convert RecordId to SurrealDB RecordID.

        Returns:
            SurrealDB RecordID instance

        Raises:
            ValueError: If RecordId is invalid
        """
        if ":" not in self:
            raise ValueError("Invalid SurrealDB record id (expected 'table:id')")
        table, record_id = self.split(":", 1)
        if not table:
            raise ValueError("Invalid SurrealDB record id (empty table)")
        return RecordID(table, record_id)


class AbstractBaseSurrealEntity(BaseModel):
    """Base model for all SurrealDB entities."""

    model_config = ConfigDict(
        arbitrary_types_allowed=True,
        validate_assignment=True,
        from_attributes=True,
    )

    class Settings:
        """Settings for model database operations."""

        __abstract__: bool = True
        raise_on_error: bool = True
        auto_generate_timestamps: bool = True
        table_name: str | None = None  # Can be overridden by child classes
        schema_full: bool = False
        exclude_none: bool = False

    id: RecordId | None = Field(
        None, description="Record ID (auto-generated by SurrealDB if None)"
    )

    @classmethod
    def _get_table_name(cls) -> str:
        """Get table name from class name (dynamic)."""
        # If table_name is explicitly set in Settings, use it
        if cls.Settings.table_name is not None:
            return cls.Settings.table_name
        # Otherwise, use the class name
        return cls.__name__
        return camel_to_kebab(cls.__name__)

    async def save(self) -> Self:
        """
        Save (create or update) this instance to database.

        - If id is None: SurrealDB auto-generates ID
        - If id exists: updates only new/changed fields (upsert)
        - Auto-sets timestamps if enabled

        Returns:
            Self (for method chaining)

        Raises:
            Exception if Settings.raise_on_error is True
        """

        db_manager = DatabaseManager()
        db = db_manager.get_db()
        table = self._get_table_name()
        now = datetime.now()

        # Set timestamps if enabled and needed
        if self.Settings.auto_generate_timestamps:
            if not self.id and not self.created_at:
                self.created_at = now
            self.updated_at = now

        # Prepare data (exclude id and None values for update)
        data = self.model_dump(exclude={"id"}, exclude_none=self.Settings.exclude_none)

        try:
            if self.id:
                record_id = await self._save_with_id(db, data)
            else:
                record_id = await self._create_with_auto_id(db, table, data)
            logger.debug("Saved %s: %s", table, record_id)
        except Exception:
            logger.exception("Failed to save %s", table)
            if self.Settings.raise_on_error:
                raise

        return self

    async def _save_with_id(
        self, db: AsyncSurrealConnection, data: dict[str, object]
    ) -> str:
        """Save with existing ID (upsert)."""

        existing = await db.select(self.id)
        if existing:
            await db.update(self.id, data)
            return self.id
        # Create with this ID
        result = await db.create(self.id, data)
        if isinstance(result, dict):
            return result.get("id", self.id)
        return self.id

    async def _create_with_auto_id(
        self, db: AsyncSurrealConnection, table: str, data: dict[str, object]
    ) -> str:
        """Create record with auto-generated ID."""
        # Use table name format for auto-generation
        result = await db.create(table, data)
        # Extract generated ID
        if isinstance(result, dict):
            generated_id = result.get("id")
            if generated_id:
                self.id = RecordId(generated_id)
                return self.id
        # Try list format
        if isinstance(result, list) and result:
            first = result[0]
            if isinstance(first, dict):
                generated_id = first.get("id")
                if generated_id:
                    self.id = RecordId(generated_id)
                    return self.id
        raise ValueError("Failed to get generated ID from SurrealDB")

    async def update(self, **updates: object) -> dict[str, object]:
        """
        Update specific fields of this instance.

        Args:
            **updates: Fields to update

        Raises:
            ValueError if id is not set
            Exception if Settings.raise_on_error is True

        Returns:
            dict[str, object] - The old data that has changed

        """
        if not self.id:
            raise ValueError("Model must have id set to update")

        db_manager = DatabaseManager()
        db = db_manager.get_db()
        now = datetime.now()

        # Only update provided fields
        update_data = {**updates, "updated_at": now}
        old_data = {}
        try:
            await db.update(self.id, update_data)
            logger.debug("Updated %s: %s", self._get_table_name(), self.id)

            # Update local instance
            for key, value in updates.items():
                if getattr(self, key, None) != value:
                    old_data[key] = getattr(self, key)
                    setattr(self, key, value)

            old_data["updated_at"] = now
            self.updated_at = now

        except Exception:
            logger.exception("Failed to update %s", self.id)
            if self.Settings.raise_on_error:
                raise

        return old_data

    async def delete(self, soft: bool = True) -> None:
        """
        Delete this instance (soft or hard delete).

        Args:
            soft: If True, sets is_deleted=True (soft delete)
                  If False, permanently deletes the record

        Raises:
            ValueError if id is not set
            Exception if Settings.raise_on_error is True

        """
        if not self.id:
            raise ValueError("Model must have id set to delete")

        db_manager = DatabaseManager()
        db = db_manager.get_db()

        try:
            if soft:
                # Soft delete
                await self.update(is_deleted=True)
                self.is_deleted = True
            else:
                # Hard delete
                await db.delete(self.id)
                logger.debug("Deleted %s: %s", self._get_table_name(), self.id)

        except Exception:
            logger.exception("Failed to delete %s", self.id)
            if self.Settings.raise_on_error:
                raise

    @classmethod
    async def get_by_id(cls, id: str, is_deleted: bool = False) -> Self | None:  # noqa: A002
        """Get an instance by id."""
        return await cls.find_one(id=id, is_deleted=is_deleted)

    @classmethod
    async def find_one(cls, is_deleted: bool = False, **filters: object) -> Self | None:
        """
        Find one instance by filters.

        Args:
            is_deleted: Filter by is_deleted status (default: False)
            **filters: Additional filter conditions

        Returns:
            Model instance or None if not found

        """
        from .query_executor import execute_query

        table = cls._get_table_name()
        query_builder = query(table).where_eq("is_deleted", is_deleted).limit(1)

        for field, value in filters.items():
            if isinstance(value, list):
                query_builder.where_in(field, value)
            else:
                query_builder.where_eq(field, value)

        query_sql, params = query_builder.build()

        try:
            rows = await execute_query(query_sql, params)
            if rows:
                return cls(**rows[0])
        except Exception:
            logger.exception("Failed to find %s", table)

        return None

    @classmethod
    async def find_many(
        cls,
        skip: int = 0,
        limit: int = 100,
        is_deleted: bool = False,
        **filters: object,
    ) -> list[Self]:
        """
        Find many instances by filters.

        Args:
            skip: Number of results to skip
            limit: Maximum number of results
            is_deleted: Filter by is_deleted status (default: False)
            **filters: Additional filter conditions

        Returns:
            List of model instances

        """
        from .query_executor import execute_query

        table = cls._get_table_name()
        query_builder = (
            query(table).where_eq("is_deleted", is_deleted).skip(skip).limit(limit)
        )

        for field, value in filters.items():
            if isinstance(value, list):
                query_builder.where_in(field, value)
            else:
                query_builder.where_eq(field, value)

        query_sql, params = query_builder.build()

        try:
            rows = await execute_query(query_sql, params)
        except Exception:
            logger.exception("Failed to find many %s", table)
            return []

        return [cls(**row) for row in rows]


class BaseEntityMixin(BaseModel):
    """Base entity mixin."""

    created_at: datetime = Field(
        default_factory=lambda: datetime.now(timezone.utc),  # noqa: UP017
        description="Creation timestamp",
    )
    updated_at: datetime = Field(
        default_factory=lambda: datetime.now(timezone.utc),  # noqa: UP017
        description="Last update timestamp",
    )
    is_deleted: bool = Field(
        False,
        description="Whether the record is deleted",
    )
    meta_data: dict[str, object] | None = Field(
        default=None, description="Additional metadata"
    )


class BaseSurrealEntity(BaseEntityMixin, AbstractBaseSurrealEntity):
    """SurrealDB schema base model."""

    class Settings(AbstractBaseSurrealEntity.Settings):
        """Settings for BaseSurrealEntity."""

        __abstract__: bool = True


class BaseSurrealUserMixin(BaseModel):
    """SurrealDB user mixin."""

    user_id: RecordId | str = Field(
        ...,
        description="User ID",
        json_schema_extra={"surreal_index": "idx_user_id"},
    )
