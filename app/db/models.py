"""Base model for SurrealDB entities."""

import logging
from datetime import datetime, timezone
from typing import ClassVar, Self

from pydantic import BaseModel, Field

from .manager import DatabaseManager
from .query_builder import query

logger = logging.getLogger(__name__)


class BaseSurrealEntity(BaseModel):
    """Base model for all SurrealDB entities."""

    class Settings:
        """Settings for model database operations."""

        raise_on_error: bool = True
        auto_generate_timestamps: bool = True
        abstract: bool = False

        @property
        def table_name(self) -> str:
            """Return the name of the model class this Settings belongs to."""
            # We want the owner class of this Settings instance
            # Normally, this would be available through the class object,
            # but within this context, we can use self.__class__.__qualname__
            # to extract the outer class name if nested.
            qualname = type(self).__qualname__

            # If qualname is 'OuterClass.InnerClass',
            # split by '.' and get the first part

            return qualname.split(".")[0]

    id: str | None = Field(
        None,
        description="Record ID (auto-generated by SurrealDB if None)",
        json_schema_extra={"surreal_index": "idx_id"},
    )

    _settings: ClassVar[Settings] = Settings()

    @classmethod
    def _get_table_name(cls) -> str:
        """Get table name from class name (dynamic)."""

        return cls._settings.table_name

    async def save(self) -> Self:
        """
        Save (create or update) this instance to database.

        - If id is None: SurrealDB auto-generates ID
        - If id exists: updates only new/changed fields (upsert)
        - Auto-sets timestamps if enabled

        Returns:
            Self (for method chaining)

        Raises:
            Exception if Settings.raise_on_error is True
        """

        db_manager = DatabaseManager()
        db = db_manager.get_db()
        table = self._get_table_name()
        now = datetime.now()

        # Set timestamps if enabled and needed
        if self.Settings.auto_generate_timestamps:
            if not self.id and not self.created_at:
                self.created_at = now
            self.updated_at = now

        # Prepare data (exclude id and None values for update)
        data = self.model_dump(exclude={"id"}, exclude_none=True)

        try:
            if self.id:
                record_id = await self._save_with_id(db, data)
            else:
                record_id = await self._create_with_auto_id(db, table, data)
            logger.debug("Saved %s: %s", table, record_id)
        except Exception:
            logger.exception("Failed to save %s", table)
            if self.Settings.raise_on_error:
                raise

        return self

    async def _save_with_id(self, db: object, data: dict[str, object]) -> str:
        """Save with existing ID (upsert)."""

        existing = await db.select(self.id)
        if existing:
            await db.update(self.id, data)
            return self.id
        # Create with this ID
        result = await db.create(self.id, data)
        if isinstance(result, dict):
            return result.get("id", self.id)
        return self.id

    async def _create_with_auto_id(
        self, db: object, table: str, data: dict[str, object]
    ) -> str:
        """Create record with auto-generated ID."""
        # Use table name format for auto-generation
        record_id = f"{table}:"
        result = await db.create(record_id, data)
        # Extract generated ID
        if isinstance(result, dict):
            generated_id = result.get("id")
            if generated_id:
                self.id = generated_id
                return generated_id
        # Try list format
        if isinstance(result, list) and result:
            first = result[0]
            if isinstance(first, dict):
                generated_id = first.get("id")
                if generated_id:
                    self.id = generated_id
                    return generated_id
        raise ValueError("Failed to get generated ID from SurrealDB")

    async def update(self, **updates: object) -> None:
        """
        Update specific fields of this instance.

        Args:
            **updates: Fields to update

        Raises:
            ValueError if id is not set
            Exception if Settings.raise_on_error is True

        """
        if not self.id:
            raise ValueError("Model must have id set to update")

        db_manager = DatabaseManager()
        db = db_manager.get_db()
        now = datetime.now()

        # Only update provided fields
        update_data = {**updates, "updated_at": now}

        try:
            await db.update(self.id, update_data)
            logger.debug("Updated %s: %s", self._get_table_name(), self.id)

            # Update local instance
            for key, value in updates.items():
                setattr(self, key, value)
            self.updated_at = now

        except Exception:
            logger.exception("Failed to update %s", self.id)
            if self._settings.raise_on_error:
                raise

    async def delete(self, soft: bool = True) -> None:
        """
        Delete this instance (soft or hard delete).

        Args:
            soft: If True, sets is_deleted=True (soft delete)
                  If False, permanently deletes the record

        Raises:
            ValueError if id is not set
            Exception if Settings.raise_on_error is True

        """
        if not self.id:
            raise ValueError("Model must have id set to delete")

        db_manager = DatabaseManager()
        db = db_manager.get_db()

        try:
            if soft:
                # Soft delete
                await self.update(is_deleted=True)
                self.is_deleted = True
            else:
                # Hard delete
                await db.delete(self.id)
                logger.debug("Deleted %s: %s", self._get_table_name(), self.id)

        except Exception:
            logger.exception("Failed to delete %s", self.id)
            if self._settings.raise_on_error:
                raise

    @classmethod
    async def find_one(cls, is_deleted: bool = False, **filters: object) -> Self | None:
        """
        Find one instance by filters.

        Args:
            is_deleted: Filter by is_deleted status (default: False)
            **filters: Additional filter conditions

        Returns:
            Model instance or None if not found

        """
        from .query_executor import execute_query

        table = cls._get_table_name()
        query_builder = query(table).where_eq("is_deleted", is_deleted).limit(1)

        for field, value in filters.items():
            if isinstance(value, list):
                query_builder.where_in(field, value)
            else:
                query_builder.where_eq(field, value)

        query_sql, params = query_builder.build()

        try:
            rows = await execute_query(query_sql, params)
            if rows:
                return cls(**rows[0])
        except Exception:
            logger.exception("Failed to find %s", table)

        return None

    @classmethod
    async def find_many(
        cls, limit: int = 100, is_deleted: bool = False, **filters: object
    ) -> list[Self]:
        """
        Find many instances by filters.

        Args:
            limit: Maximum number of results
            is_deleted: Filter by is_deleted status (default: False)
            **filters: Additional filter conditions

        Returns:
            List of model instances

        """
        from .query_executor import execute_query

        table = cls._get_table_name()
        query_builder = query(table).where_eq("is_deleted", is_deleted).limit(limit)

        for field, value in filters.items():
            if isinstance(value, list):
                query_builder.where_in(field, value)
            else:
                query_builder.where_eq(field, value)

        query_sql, params = query_builder.build()

        try:
            rows = await execute_query(query_sql, params)
            return [cls(**row) for row in rows]
        except Exception:
            logger.exception("Failed to find many %s", table)
            return []


class BaseSurrealTenantEntity(BaseSurrealEntity):
    """SurrealDB tenant schema base model."""

    tenant_id: str = Field(
        ...,
        description="Tenant/organization ID",
        json_schema_extra={"surreal_index": "idx_tenant_id"},
    )
    created_at: datetime = Field(
        default_factory=lambda: datetime.now(timezone.utc),  # noqa: UP017
        description="Creation timestamp",
    )
    updated_at: datetime = Field(
        default_factory=lambda: datetime.now(timezone.utc),  # noqa: UP017
        description="Last update timestamp",
    )
    is_deleted: bool = Field(
        False,
        description="Whether the record is deleted",
    )
    meta_data: dict[str, object] | None = Field(
        default_factory=None, description="Additional metadata"
    )
